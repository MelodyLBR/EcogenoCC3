---
title: "Analyse des données avec Dada2"
author : Mélody Lebrun
date: "3 janvier 2022"
output: 
  github_document:
    toc: true
    toc_depth: 2
---

L'objectif de ce travail est de comparer les résultats des analyses des données de l'article basée sur la méthode d'analyse des séquences par OTU (Operational Taxonomic Units) (97% de similarité) à la méthode ASV (Amplicon Sequence Variants). 
Ainsi, les résultats obtenue par la méthode ASV devraient être plus précis et moins erronés que par OTU. En effet, la méthode ASV permet de détecter les erreurs de séquençage, possède une résolution plus élevé sur l'identification de l'espèce et permet de comparer plusieurs études entre eux.   

Les données choisi proviennent soit du contenu des intestins de 14 Abatus agassizii (oursin) ou des tissus intestinaux ou encore des sédiments à proximité des oursins échantillonnées. L'échantillonnage a été réalisé au niveau de 2 sites séparés par 2 km. Les échantillons ont été séquencé par illumina miseq. Le dossier data_1 contient l'ARNr16s de ces échantillons. 
Le but de dada2 est de préparer les données pour les prochaines analyses en identifiant les erreurs de séquençage. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Préparation de l'environnement

```{r}
library(Rcpp)
library(dada2)
```

```{r}
set.seed(100)
```

14 contenus intestinaux, 14 tissus intestinaux, 8 sédiments ARNr16S V4 et V5  
```{r}
miseq_path <- "./data_1"
list.files(miseq_path)
```

## Filtrer et rogner les lectures
# Lire le nom des fichiers et les mettre dans l'ordre

```{r}
fnFs <- sort(list.files(miseq_path, pattern="_1.fastq"))
fnRs <- sort(list.files(miseq_path, pattern="_2.fastq"))
sampleNames <- sapply(strsplit(fnFs, "_"), `[`, 1)
fnFs <- file.path(miseq_path, fnFs)
fnRs <- file.path(miseq_path, fnRs)
fnFs[1:3]
```

```{r}
fnRs[1:3]
```

# Graphique de la qualité des lectures 

```{r}
plotQualityProfile(fnFs[1:2])
```

```{r}
plotQualityProfile(fnRs[1:2])
```
```{r}
filt_path <- file.path(miseq_path, "filtered") 
if(!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(filt_path, paste0(sampleNames, "_F_filt.fastq.gz"))
filtRs <- file.path(filt_path, paste0(sampleNames, "_R_filt.fastq.gz"))
```

```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE, compress=TRUE, multithread=TRUE)
head(out)
```

# Déduire des variantes de séquences (ASV)  
Combiner les lectures de séquençage en une séquence unique

```{r message = FALSE}
derepFs <- derepFastq(filtFs, verbose=TRUE)
derepRs <- derepFastq(filtRs, verbose=TRUE)
names(derepFs) <- sampleNames
names(derepRs) <- sampleNames
```
# Connaître le taux d'erreur de séquençage 

```{r}
errF <- learnErrors(filtFs, multithread=TRUE)
```

```{r}
errR <- learnErrors(filtRs, multithread=TRUE)
```

```{r}
plotErrors(errF)
plotErrors(errR)
```

On observe que le taux d'erreur estimé (lignes noires) et le taux d'erreur observé (points noires) sont similaires. (les deux courbes se superposent)

# Méthode d'Interférence de Dada2 pour enlevé les bruits de fond

```{r}
dadaFs <- dada(derepFs, err=errF, multithread=TRUE)
```

```{r}
dadaRs <- dada(derepRs, err=errR, multithread=TRUE)
```

```{r}
dadaFs[[1]]
```

# Construire une table OTU

```{r}
mergers <- mergePairs(dadaFs, derepFs, dadaRs, derepRs)
```

```{r}
seqtabAll <- makeSequenceTable(mergers[!grepl("Mock", names(mergers))])
table(nchar(getSequences(seqtabAll)))
```

Detection des chimères 

```{r}
seqtabNoC <- removeBimeraDenovo(seqtabAll)
```

# Attribuer une taxonomie
```{bash message = FALSE}
cd ~
wget  https://zenodo.org/record/4587955/files/silva_nr99_v138.1_train_set.fa.gz
```

```{r}
fastaRef <-"/home/rstudio/silva_nr99_v138.1_train_set.fa.gz"
taxTab<-assignTaxonomy(seqtabNoC, refFasta=fastaRef, multithread=TRUE)
rownames(taxTab) <- NULL
head(taxTab)
```

# Sauvegarde de nos données ASV pour les prochaines analyses 
```{r}
save.image(file="02_Data-analysis-with-DADA2_FinalEnv")
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
